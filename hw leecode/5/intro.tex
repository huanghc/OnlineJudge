\section{}
\subsection{Question}
Given a positive integer n and you can do operations as follow:

1. If n is even, replace n with n/2.

2. If n is odd, you can replace n with either n + 1 or n - 1.

What is the minimum number of replacements needed for n to become 1?

Example 1:

Input: 8

Output: 3

Explanation: $8 => 4 => 2 => 1$

Example 2:

Input:7

Output:4

Explanation: $7 => 8 => 4 => 2 => 1$ or $7 => 6 => 3 => 2 => 1$

Input: int n;

Output: int minNum;

\subsection{Answer}
If the number n is even, we divide it by 2.

If the number n is odd, if n = 4k+1, 

1) $4k+1  \rightarrow 4k \rightarrow 2k \rightarrow k (\rightarrow k+1)$

2) $4k+1 \rightarrow 4k+2 \rightarrow 2K+1 \rightarrow 2k \rightarrow k$

3) $4k+1 \rightarrow 4k+2 \rightarrow 2K+1 \rightarrow 2k+2 \rightarrow k+1$
 
So, 2) is one step more than 1). 3) is less than or equal to 1). So we need to make n to 4K.

So do when n = 4K+3. Let n be 4K+4.

Here is also one exception:
when n = 3, the best solution is $3 \rightarrow 2 \rightarrow 1$, three steps.

Another exception is that when n = $INT\_MAX$ = $2^{32} - 1$, we can not let n be n+1 when n is an int, so we just return the steps  = 32.


\textbf{\color{red}Time complexity O(log(n))}
\newpage
\subsection{Code}
\texttt{C++ :}
\lstinputlisting[breaklines=TRUE,basicstyle=\footnotesize\ttfamily,language=c++,numbers=left, numberstyle=\tiny,keywordstyle=\color{blue},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20},stringstyle=\color{purple}]{1.cpp}

\newpage
\section{}
\subsection{Question}
Implement a basic calculator to evaluate a simple expression string.

The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces.

You may assume that the given expression is always valid.

Some examples:

"1 + 1" = 2

" 2-1 + 2 " = 3

"(1+(4+5+2)-3)+(6+8)" = 23

Note: Do not use the eval built-in library function.

Input: string str;

Output: int result;

\subsection{Answer}
This is a classical and easy problem about expression. Here I use a char stack and a number stack to store the sign and the number. 

First whenever there is a space, skip it.

If there is a number, push into the number stack. If there is a sign, push into the char stack. Here if it is a minus sign, just change the following number n to minus n, so that all the calculations are add and there order can be changed arbitrarily.

When there is a ')', we need to do the calculate until it meets the corresponding '('. The calculation includes pop two number and one sign and calculate it and push the result to the number stack.

At last when the sign stack is empty, return the top of the number stack.

\textbf{\color{red}Time complexity O(n)}
\subsection{Code}
\texttt{C++ :}
\lstinputlisting[breaklines=TRUE,basicstyle=\footnotesize\ttfamily,language=c++,numbers=left, numberstyle=\tiny,keywordstyle=\color{blue},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20},stringstyle=\color{purple}]{2.cpp}

\newpage
\section{}
\subsection{Question}
In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.

For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.

Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.

Note:

1. The given numbers of 0s and 1s will both not exceed 100.

2. The size of given string array won't exceed 600.

Example 1:

Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3.

Output: 4.

Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are ��10,��0001��,��1��,��0��.

Example 2:

Input: Array = {"10", "0", "1"}, m = 1, n = 1.

Output: 2.

Explanation: You could form "10", but then you'd have nothing left. Better form "0" and "1".

Input: string array[]; int N; int m; int n; // N: number of strings in array.

Output: int findMaxForm;

\subsection{Answer}
Use dynamic programming to solve this problem.

I use dp[i][j] to store the max number of strings that can be formed with i 0 and j 1.

For all the strings in the string array, we try to use them from left to right. And calculate the max number of all dps with this string considered. 

Clearly, here $dp [ i ][ j ] = max ( dp [ i ][ j ] , dp [i - t0 ][ j - t1 ]+1) ;$

For the following string in the string array, we again calculate the max number with one more string considered.

\textbf{\color{red}Time complexity O(m*n*len(string))}
\newpage
\subsection{Code}
\texttt{C++ :}
\lstinputlisting[breaklines=TRUE,basicstyle=\footnotesize\ttfamily,language=c++,numbers=left, numberstyle=\tiny,keywordstyle=\color{blue},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20},stringstyle=\color{purple}]{3.cpp}

